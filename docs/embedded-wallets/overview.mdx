---
title: Embedded Wallets
description: Seedless, self-custodial wallets inside your app powered by Just-in-Time (JIT) keys.
slug: /
---

Unforgettable Embedded Wallets let your app provision a self-custodial user wallet with seamless onboarding and a familiar, app-native experience. They are built on Just-in-Time (JIT) key infrastructure: a user’s private key is deterministically reconstructed on the device from multiple noisy inputs (such as biometrics) only when a signature is required, used to authorize the action, and destroyed immediately afterward.

The key benefits of Embedded Wallets are:
- **True self-custody, zero key liability.** Users fully control their wallets; your backend cannot move funds.
- **Streamlined onboarding.** No seed phrases, no extensions, just a clean, intuitive flow.
- **Phishing-resistant key management.** Nothing to type or copy, and no keys stored at rest—removing most social-engineering attack vectors.

### How it works

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/uZrqQsSihZE"
  title="YouTube Short - Unforgettable Demo"
  frameborder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  allowfullscreen>
</iframe>

Let’s say a user wants to transfer stablecoins from their embedded wallet. The flow looks like this:

1. The user logs into your app.
2. Wallet setup or recovery begins.
3. Multi-step, on-device authentication runs using biometric or visual inputs, during which the key is reconstructed.
4. The stablecoin transaction is signed.
5. The key is discarded immediately after use.

## Policy controls

Embedded Wallets use a [Policy Engine](/embedded-wallets/policy-engine/) to define and enforce what actions are allowed, when they can occur, and under which conditions. These rules are applied consistently and cannot be bypassed.

Policy controls include transaction limits, geofencing, time-based restrictions, and recovery constraints.

## Extra conveniences with Passkeys

Embedded Wallets support Passkeys as a convenience feature. Passkeys provide a fast, OS-native confirmation flow, allowing users to approve actions without re-running the full Unforgettable Key derivation each time.

Passkeys do not replace the Unforgettable Key. Any action confirmed with a passkey can always be completed by deriving the Unforgettable Key instead.

## What happens when key derivation fails

Key derivation mechanisms based on noisy inputs (biometrics, visual keys) are robust to *small* changes but can fail under *large* changes. Unforgettable provides several fallback options to recover access without compromising self-custody.

See [Recovery](/embedded-wallets/recovery-overview) for trade-offs and flows.

## Next

* [Architecture & Trust Model](/embedded-wallets/architecture)
* [Smart Account](/embedded-wallets/smart-account)
* [Policy Engine](/embedded-wallets/policy-engine)
