---
title: Embedded Wallets
description: Seedless, self-custodial wallets inside your app powered by Just-in-Time (JIT) keys.
slug: /
---

Unforgettable Embedded Wallets let your app provision a self-custodial user wallet with seamless onboarding and a familiar, app-native experience. They are built on Just-in-Time (JIT) key infrastructure: a user’s private key is deterministically reconstructed on the device from multiple noisy inputs (such as biometrics) only when a signature is required, used to authorize the action, and destroyed immediately afterward.

Use Unforgettable Embedded Wallets when you want:

- *True self-custody, zero key liability.* Users fully control their wallets; your backend cannot move funds.
- *Streamlined onboarding.* No seed phrases, no extensions, just a clean, intuitive flow.
- *Phishing-resistant key management.* Nothing to type or copy, and no keys stored at rest—removing most social-engineering attack vectors.

### How it works

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/uZrqQsSihZE"
  title="YouTube Short - Unforgettable Demo"
  frameborder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  allowfullscreen>
</iframe>

Let’s say a user wants to transfer stablecoins from their embedded wallet. The flow looks like this:

1. The user logs into your app.
2. Wallet setup or recovery begins.
3. Multi-step, on-device authentication runs using biometric or visual inputs, during which the key is reconstructed.
4. The stablecoin transaction is signed.
5. The key is discarded immediately after use.

### Additional security layers

To further enhance security, Embedded Wallets allow to set up [Passkeys](/embedded-wallets/passkeys/) as a second factor for sensitive actions, and a [Policy Engine](/embedded-wallets/policy-engine/) to enforce custom rules (e.g., transaction limits, geofencing, time-based restrictions).

## What happens when key derivation fails

Key derivation mechanisms based on noisy inputs (biometrics, visual keys) are robust to *small* changes but can fail under *large* changes.

When the primary secret becomes unrecoverable, Embedded Wallets rely on preconfigured recovery mechanisms that do not undermine self-custody:

* **Timelocked fallback transfer** (assisted recovery with an inactivity/timelock delay).
* **Social recovery (guardians)** with threshold approvals and key rotation.

See [Recovery](/embedded-wallets/recovery-overview) for trade-offs and flows.

## Next

* [Architecture & Trust Model](/embedded-wallets/architecture)
* [Smart Account](/embedded-wallets/smart-account)
* [Passkeys](/embedded-wallets/passkeys)
* [Policy Engine](/embedded-wallets/policy-engine)
